<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Mini Pac-Man with Ghosts (Fast)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    :root {
      --bg: #020312;
      --maze-bg: #000814;
      --wall: #1d4ed8;
      --dot: #e5e7eb;
      --pacman: #facc15;
      --ghost-red: #f97373;
      --ghost-blue: #38bdf8;
      --ghost-orange: #fb923c;
      --text: #e5e7eb;
      --accent: #38bdf8;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      background: radial-gradient(circle at top, #020617, #020312 60%);
      color: var(--text);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
        sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
    }

    .wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    h1 {
      font-size: 1.6rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 10px rgba(56,189,248,0.35);
    }

    .subtitle {
      font-size: 0.9rem;
      color: #9ca3af;
      margin-bottom: 6px;
    }

    .hud {
      display: flex;
      justify-content: space-between;
      width: 608px;
      max-width: 100%;
      font-size: 0.9rem;
      color: #d1d5db;
    }

    .hud span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .hud-label {
      text-transform: uppercase;
      letter-spacing: 0.16em;
      font-size: 0.72rem;
      color: #9ca3af;
    }

    canvas {
      border-radius: 14px;
      background: radial-gradient(circle at top, #020617, var(--maze-bg));
      box-shadow:
        0 20px 40px rgba(15,23,42,0.8),
        0 0 0 1px rgba(148,163,184,0.12);
    }

    .instructions {
      font-size: 0.8rem;
      color: #9ca3af;
      text-align: center;
      margin-top: 4px;
    }

    @media (max-width: 700px) {
      .hud {
        width: 100%;
        padding: 0 12px;
      }
      canvas {
        width: 100%;
        height: auto;
      }
    }
  </style>
</head>
<body>
  <div class="wrapper">
    <h1>Mini Pac-Man</h1>
    <div class="subtitle">Fast mode â€¢ Arrow keys to move â€¢ Avoid the ghosts!</div>
    <div class="hud">
      <span><span class="hud-label">Score</span><span id="score">0</span></span>
      <span><span class="hud-label">Dots Left</span><span id="dotsLeft">0</span></span>
      <span><span class="hud-label">Lives</span><span id="lives">3</span></span>
      <span><span class="hud-label">Status</span><span id="statusText">Playing...</span></span>
    </div>
    <canvas id="game" width="608" height="640"></canvas>
    <div class="instructions">
      Arrow keys to move â€¢ 3 lives â€¢ Clear all dots to win â€¢ Press R to restart after win/lose
    </div>
  </div>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const tileSize = 32; // 608 / 19 columns
    const rows = 20;
    const cols = 19;

    // Maze layout:
    // 0: empty, 1: wall, 2: dot
    const mazeLayout = [
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
      [1,2,2,2,2,2,2,2,2,0,2,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,2,1,1,2,2,2,1,1,2,1,1,1,2,1],
      [1,2,1,0,1,2,1,0,0,2,0,0,1,2,1,0,1,2,1],
      [1,2,1,0,1,2,1,2,2,2,2,2,1,2,1,0,1,2,1],
      [1,2,2,2,2,2,2,2,1,1,1,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,2,1,2,2,0,2,2,1,2,1,1,1,2,1],
      [1,2,1,0,2,2,1,2,1,1,1,2,1,2,2,0,1,2,1],
      [1,2,2,0,2,1,2,2,2,2,2,2,2,1,2,0,2,2,1],
      [1,0,0,0,2,1,2,1,1,0,1,1,2,1,2,0,0,0,1],
      [1,2,2,0,2,1,2,2,2,2,2,2,2,1,2,0,2,2,1],
      [1,2,1,0,2,1,1,1,1,1,1,1,2,1,2,0,1,2,1],
      [1,2,1,2,2,2,2,0,0,0,0,2,2,2,2,2,1,2,1],
      [1,2,1,2,1,1,2,1,1,0,1,1,2,1,1,2,1,2,1],
      [1,2,2,2,2,2,2,2,1,0,1,2,2,2,2,2,2,2,1],
      [1,2,1,1,1,1,1,2,1,1,1,2,1,1,1,1,1,2,1],
      [1,2,1,0,0,0,1,2,2,2,2,2,1,0,0,0,1,2,1],
      [1,2,1,0,1,0,1,2,1,1,1,2,1,0,1,0,1,2,1],
      [1,2,2,2,1,2,2,2,2,0,2,2,2,2,1,2,2,2,1],
      [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
    ];

    // Count initial dots
    let dotsTotal = 0;
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        if (mazeLayout[r][c] === 2) dotsTotal++;
      }
    }

    const scoreEl = document.getElementById("score");
    const dotsLeftEl = document.getElementById("dotsLeft");
    const livesEl = document.getElementById("lives");
    const statusTextEl = document.getElementById("statusText");

    let score = 0;
    let dotsLeft = dotsTotal;
    let lives = 3;
    let gameOver = false;
    let win = false;

    scoreEl.textContent = score;
    dotsLeftEl.textContent = dotsLeft;
    livesEl.textContent = lives;

    // Pac-Man: start in an open corridor (row 1, col 1)
    const pacmanStart = {
      x: 1 * tileSize + tileSize / 2,
      y: 1 * tileSize + tileSize / 2
    };

    const pacman = {
      x: pacmanStart.x,
      y: pacmanStart.y,
      radius: 12,
      speed: 3.0,          // faster Pac-Man
      vx: 0,
      vy: 0,
      desiredDir: null,
      mouthAngle: 0.3,
      mouthDir: 1
    };

    // Ghosts: slightly slower than Pac-Man, all in open spots
    const ghostSpeed = 2.4;
    const ghostRadius = 12;

    function createGhost(xTile, yTile, color) {
      return {
        x: xTile * tileSize + tileSize / 2,
        y: yTile * tileSize + tileSize / 2,
        radius: ghostRadius,
        speed: ghostSpeed,
        vx: 0,
        vy: 0,
        color,
        dir: null
      };
    }

    // Open positions chosen so none are trapped
    // row 9: [1,0,0,0,2,1,2,1,1,0,1,1,2,1,2,0,0,0,1]
    const ghostsStart = [
      createGhost(1, 9, "var(--ghost-red)"),
      createGhost(9, 9, "var(--ghost-blue)"),
      createGhost(17, 9, "var(--ghost-orange)")
    ];

    let ghosts = ghostsStart.map(g => ({ ...g }));

    const keys = {
      ArrowUp: false,
      ArrowDown: false,
      ArrowLeft: false,
      ArrowRight: false
    };

    window.addEventListener("keydown", (e) => {
      if (keys.hasOwnProperty(e.key)) {
        e.preventDefault();
        if (gameOver || win) return;
        if (e.key === "ArrowUp") pacman.desiredDir = "up";
        if (e.key === "ArrowDown") pacman.desiredDir = "down";
        if (e.key === "ArrowLeft") pacman.desiredDir = "left";
        if (e.key === "ArrowRight") pacman.desiredDir = "right";
      }
      if ((gameOver || win) && e.key.toLowerCase() === "r") {
        window.location.reload();
      }
    });

    function tileAtPixel(x, y) {
      const c = Math.floor(x / tileSize);
      const r = Math.floor(y / tileSize);
      if (r < 0 || r >= rows || c < 0 || c >= cols) return 1; // treat out of bounds as wall
      return mazeLayout[r][c];
    }

    function canMove(newX, newY, radius) {
      const left = newX - radius;
      const right = newX + radius;
      const top = newY - radius;
      const bottom = newY + radius;

      const points = [
        { x: left, y: top },
        { x: right, y: top },
        { x: left, y: bottom },
        { x: right, y: bottom }
      ];

      for (const p of points) {
        const tile = tileAtPixel(p.x, p.y);
        if (tile === 1) return false;
      }
      return true;
    }

    // Helper: check if Pac-Man is near the center of a tile on a given axis
    function isCenteredOnGrid(value) {
      const mod = value % tileSize;
      const center = tileSize / 2;
      return Math.abs(mod - center) < 4; // within 4px of center
    }

    function snapToCenter(axis) {
      if (axis === "x") {
        const col = Math.floor(pacman.x / tileSize);
        pacman.x = col * tileSize + tileSize / 2;
      } else if (axis === "y") {
        const row = Math.floor(pacman.y / tileSize);
        pacman.y = row * tileSize + tileSize / 2;
      }
    }

    function updatePacmanDirection() {
      if (!pacman.desiredDir) return;

      // Only allow direction changes when Pac-Man is near the center of a tile
      if (pacman.desiredDir === "up" || pacman.desiredDir === "down") {
        if (!isCenteredOnGrid(pacman.x)) return;
        snapToCenter("x");
      }
      if (pacman.desiredDir === "left" || pacman.desiredDir === "right") {
        if (!isCenteredOnGrid(pacman.y)) return;
        snapToCenter("y");
      }

      let testVX = 0;
      let testVY = 0;
      if (pacman.desiredDir === "up") testVY = -pacman.speed;
      if (pacman.desiredDir === "down") testVY = pacman.speed;
      if (pacman.desiredDir === "left") testVX = -pacman.speed;
      if (pacman.desiredDir === "right") testVX = pacman.speed;

      const newX = pacman.x + testVX;
      const newY = pacman.y + testVY;

      if (canMove(newX, newY, pacman.radius)) {
        pacman.vx = testVX;
        pacman.vy = testVY;
      }
    }

    function eatDot() {
      const c = Math.floor(pacman.x / tileSize);
      const r = Math.floor(pacman.y / tileSize);
      if (mazeLayout[r][c] === 2) {
        mazeLayout[r][c] = 0;
        score += 10;
        dotsLeft--;
        scoreEl.textContent = score;
        dotsLeftEl.textContent = dotsLeft;
        if (dotsLeft === 0) {
          win = true;
          statusTextEl.textContent = "You cleared the maze! ðŸŽ‰ Press R to restart.";
        }
      }
    }

    function resetPositionsAfterHit() {
      pacman.x = pacmanStart.x;
      pacman.y = pacmanStart.y;
      pacman.vx = 0;
      pacman.vy = 0;
      pacman.desiredDir = null;
      ghosts = ghostsStart.map(g => ({ ...g }));
    }

    function checkGhostCollisions() {
      for (const ghost of ghosts) {
        const dx = ghost.x - pacman.x;
        const dy = ghost.y - pacman.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < pacman.radius + ghost.radius - 2) {
          lives--;
          livesEl.textContent = lives;
          if (lives <= 0) {
            gameOver = true;
            statusTextEl.textContent = "Game Over ðŸ’€ Press R to restart.";
          } else {
            statusTextEl.textContent = "You were caught! Lives left: " + lives;
            resetPositionsAfterHit();
          }
          break;
        }
      }
    }

    function chooseNewGhostDirection(ghost) {
      const speed = ghost.speed;
      const directions = [
        { name: "up", vx: 0, vy: -speed },
        { name: "down", vx: 0, vy: speed },
        { name: "left", vx: -speed, vy: 0 },
        { name: "right", vx: speed, vy: 0 }
      ];

      const opposite = {
        up: "down",
        down: "up",
        left: "right",
        right: "left"
      };

      // Shuffle directions for some randomness
      for (let i = directions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [directions[i], directions[j]] = [directions[j], directions[i]];
      }

      // Try directions that aren't the direct reverse
      for (const d of directions) {
        if (ghost.dir && d.name === opposite[ghost.dir]) continue;
        const newX = ghost.x + d.vx;
        const newY = ghost.y + d.vy;
        if (canMove(newX, newY, ghost.radius)) {
          ghost.vx = d.vx;
          ghost.vy = d.vy;
          ghost.dir = d.name;
          return;
        }
      }

      // If needed, allow reverse
      for (const d of directions) {
        const newX = ghost.x + d.vx;
        const newY = ghost.y + d.vy;
        if (canMove(newX, newY, ghost.radius)) {
          ghost.vx = d.vx;
          ghost.vy = d.vy;
          ghost.dir = d.name;
          return;
        }
      }

      // If totally stuck (rare), stop
      ghost.vx = 0;
      ghost.vy = 0;
    }

    function updateGhosts() {
      for (const ghost of ghosts) {
        // Give ghost an initial direction if it doesn't have one
        if (!ghost.dir) {
          chooseNewGhostDirection(ghost);
        }

        const nextX = ghost.x + ghost.vx;
        const nextY = ghost.y + ghost.vy;

        if (canMove(nextX, nextY, ghost.radius)) {
          ghost.x = nextX;
          ghost.y = nextY;
        } else {
          // Hit a wall: pick a new direction
          chooseNewGhostDirection(ghost);
        }
      }
    }

    function update() {
      if (gameOver || win) return;

      updatePacmanDirection();

      const nextX = pacman.x + pacman.vx;
      const nextY = pacman.y + pacman.vy;

      if (canMove(nextX, nextY, pacman.radius)) {
        pacman.x = nextX;
        pacman.y = nextY;
      }

      // Animate mouth
      pacman.mouthAngle += 0.03 * pacman.mouthDir;
      if (pacman.mouthAngle > 0.45 || pacman.mouthAngle < 0.08) {
        pacman.mouthDir *= -1;
      }

      eatDot();
      updateGhosts();
      checkGhostCollisions();
    }

    function drawMaze() {
      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const tile = mazeLayout[r][c];
          const x = c * tileSize;
          const y = r * tileSize;

          if (tile === 1) {
            ctx.fillStyle = "#020617";
            ctx.fillRect(x, y, tileSize, tileSize);
            ctx.strokeStyle = "rgba(37, 99, 235, 0.9)";
            ctx.lineWidth = 3;
            ctx.strokeRect(x + 3, y + 3, tileSize - 6, tileSize - 6);
            ctx.shadowColor = "rgba(59,130,246,0.8)";
            ctx.shadowBlur = 8;
            ctx.strokeRect(x + 4, y + 4, tileSize - 8, tileSize - 8);
            ctx.shadowBlur = 0;
          } else {
            ctx.fillStyle = "rgba(15,23,42,0.9)";
            ctx.fillRect(x, y, tileSize, tileSize);
          }

          if (tile === 2) {
            ctx.fillStyle = "#e5e7eb";
            ctx.beginPath();
            ctx.arc(
              x + tileSize / 2,
              y + tileSize / 2,
              3,
              0,
              Math.PI * 2
            );
            ctx.fill();
          }
        }
      }
    }

    function drawPacman() {
      ctx.save();
      ctx.translate(pacman.x, pacman.y);

      let angleOffset = 0;
      if (pacman.vx > 0) angleOffset = 0;           // right
      else if (pacman.vx < 0) angleOffset = Math.PI; // left
      else if (pacman.vy < 0) angleOffset = -Math.PI / 2; // up
      else if (pacman.vy > 0) angleOffset = Math.PI / 2;  // down

      const startAngle = pacman.mouthAngle + angleOffset;
      const endAngle = (Math.PI * 2) - pacman.mouthAngle + angleOffset;

      ctx.fillStyle = "#facc15";
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.arc(0, 0, pacman.radius, startAngle, endAngle);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function drawGhost(ghost) {
      ctx.save();
      ctx.translate(ghost.x, ghost.y);

      ctx.fillStyle = ghost.color;
      // Body
      ctx.beginPath();
      ctx.arc(0, 0, ghost.radius, Math.PI, 0);
      ctx.lineTo(ghost.radius, ghost.radius);
      for (let i = 2; i >= -2; i--) {
        const x = (i * ghost.radius) / 3;
        const y = ghost.radius + (i % 2 === 0 ? 2 : 6);
        ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#e5e7eb";
      ctx.beginPath();
      ctx.arc(-5, -3, 3, 0, Math.PI * 2);
      ctx.arc(5, -3, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#020617";
      ctx.beginPath();
      ctx.arc(-5, -3, 1.5, 0, Math.PI * 2);
      ctx.arc(5, -3, 1.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      drawMaze();
      drawPacman();
      ghosts.forEach(drawGhost);
    }

    function gameLoop() {
      update();
      render();
      requestAnimationFrame(gameLoop);
    }

    statusTextEl.textContent = "Playing...";
    requestAnimationFrame(gameLoop);
  </script>
</body>
</html>